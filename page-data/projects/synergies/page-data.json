{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/projects/synergies/","result":{"data":{"markdownRemark":{"html":"<p>Find out more at <a href=\"https://synergies.js.org/\">synergies.js.org</a>!</p>\n<p><code>synergies</code> is a tiny (~3kB), yet powerful state management library for React. It allows you to\nspecify small state atoms, that you can combine into Synergies of multiple atoms that define shared state logic.\nFeatures include</p>\n<ul>\n<li><strong>Distributed state</strong>: You can inject individual atoms at multiple arbitrary points in your component hierarchy.\nThis allows you to both define unique global state logic in your application root, and smaller reusable components\nthat have their own context-based state. Your state logic can not only read and write to the atoms\nprovided by the closest provider, but to all atoms provided upwards in the component hierarchy.</li>\n<li><strong>Immutable update logic</strong>: <code>synergies</code> uses <code>immer</code> to provide drafts of your state in your update handlers,\nso you can more easily update state.</li>\n<li><strong>Performant update-triggers</strong>: Even though a synergy provider can provide several atoms and can access any atoms\nfrom other providers upwards the hierarchy, calling update logic will only trigger updates on components\nthat read from atoms that were actually changed. Again <code>immer</code> is used to let you update drafts of your state,\nand smartly detects which atoms were actually changed and which ones were only read from during the update.</li>\n<li><strong>Asynchronous update logic</strong>: No more thunk plugins! Update handlers can be asynchronous, and you can even\nmanually trigger updates on certain atoms while still being in the middle of the update handler.</li>\n<li><strong>Reusable state logic</strong>: Since you can provide atom state rather low down in the hierarchy, you can reuse small\npieces of state between components, while still maintaining more global parts of your app state farther up\nin the component hierarchy.</li>\n<li><strong>Typed</strong>: Full type safety for everything.</li>\n<li><strong>Tiny package</strong>: 3kB + immer. Use it for your global app state, or just replace small context providers with\n<code>synergies</code> to simplify your codebase and speed up your state.</li>\n</ul>\n<h2>Usage</h2>\n<p>Get started by installing the library:</p>\n<pre><code class=\"language-bash\">yarn add synergies immer\n</code></pre>\n<p>Create your first state atoms:</p>\n<pre><code class=\"language-typescript\" data-meta=\"jsx\">const valueAtom = createAtom(\"\");\nconst isInitialStateAtom = createAtom(true);\n</code></pre>\n<p>Synergyze your atoms to create React Hooks:</p>\n<pre><code class=\"language-typescript\" data-meta=\"jsx\">const useSetValue = createSynergy(valueAtom, isInitialStateAtom).createAction(\n  (newValue: string) => (valueDraft, isInitialStateDraft) => {\n    // Components that read from the value atom will be updated.\n    valueDraft.current = newValue;\n    \n    if (isInitialStateDraft.current) {\n      // If isInitialState is already false, then the draft will not be updated,\n      // and components that read from it will not trigger a rerender.\n      isInitialStateDraft.current = false;\n    }\n  }\n);\n\n// Every atom is also a synergy of itself, so we can call `createSelector` also on atoms.\nconst useValue = valueAtom.createSelector(value => value);\nconst useIsInitialState = isInitialStateAtom.useValue; // shortcut for directly reading atom state\n</code></pre>\n<p>Provide your atoms:</p>\n<pre><code class=\"language-typescript\" data-meta=\"jsx\">&#x3C;SynergyProvider atoms={[valueAtom, isInitialStateAtom]}>\n  {/* Components that consume value and isInitialState... */}\n\n  {/* We can also nest other synergy providers */}\n  &#x3C;SynergyProvider atoms={[moreLocalizedAtom]}>\n    {/* Can read from and write to all three atoms. */}\n  &#x3C;/SynergyProvider>\n  \n  {/* Reuse providers with more localized state */}\n  &#x3C;SynergyProvider atoms={[moreLocalizedAtom]}>\n    {/* ... */}\n  &#x3C;/SynergyProvider>\n&#x3C;/SynergyProvider>\n</code></pre>\n<p>Use your hooks:</p>\n<pre><code class=\"language-typescript\" data-meta=\"jsx\">const Component = () => {\n  const setValue = useSetValue();\n  const value = useValue();\n  return (\n    &#x3C;input \n      value={value}\n      onChange={e => setValue(e.target.value)}\n    />\n  )\n}\n</code></pre>\n<p>You can find more examples and details at <a href=\"https://synergies.js.org/\">synergies.js.org</a>!</p>\n<h2>More advanced examples</h2>\n<h3>Async update logic</h3>\n<p><code>synergies</code> supports asynchronous update actions. You can also trigger atoms\nin the middle of an update handler, so that their subscribers get rerendered before\nthe action has completed.</p>\n<p>This is shown in the following example, where an API fetch call is dispatched in a\naction handler. The <code>isLoading</code> atom is updated to true immediately when the fetch\nis dispatched, while the update call continues to load the data from the server.\nComponents reading the <code>isLoading</code> atom will be rerendered immediately. Once the data\nhas loaded, we update the <code>data</code> atom with the fetched result, and update the <code>isLoading</code>\natom is updated to false, triggering rerenders of all components that read from either\nthe <code>data</code> or the <code>isLoading</code> atom.</p>\n<p>Note that, if the <code>isLoading</code> atom would not rerender a second time at the end, only\ncomponents subscribing to the <code>data</code> atom would be rerendered.</p>\n<pre><code class=\"language-typescript\" data-meta=\"jsx\">const isLoadingAtom = createAtom(false);\nconst dataAtom = createAtom(null);\n\n// Async update handler\nconst useFetchData = createSynergy(dataAtom, isLoadingAtom).createAction(\n  () => async (data, isLoading) => {\n    isLoading.current = true;\n    \n    // Trigger rerenders of all components that read from the `isLoading` atom.\n    // The `isLoading` draft will be discarded, so we need to use the new one\n    // that the `trigger` method returns.\n    isLoading = isLoading.trigger();\n    \n    const res = await fetch(\"https://pokeapi.co/api/v2/pokemon/pikachu\");\n    \n    // Update the `data` and `isLoading` atoms\n    data.current = await res.json();\n    isLoading.current = false;\n  }\n);\n\n// For simplicity, read from both atoms at once\nconst usePokemonData = createSynergy(dataAtom, isLoadingAtom).createSelector(\n  (data, isLoading) => ({ data, isLoading })\n);\n\nexport const Example = () => {\n  const { data, isLoading } = usePokemonData();\n  const fetchData = useFetchData();\n  const resetData = useReset();\n  return !data &#x26;&#x26; !isLoading ? (\n    &#x3C;Button onClick={fetchData}>Load Pokemon&#x3C;/Button>\n  ) : isLoading ? (\n    &#x3C;div>Loading...&#x3C;/div>\n  ) : (\n    &#x3C;div>\n      {data.name} has a height of {data.height} and the abilities{\" \"}\n      {data.abilities.map(({ ability }) => ability.name).join(\", \")}\n    &#x3C;/div>\n  );\n};\n</code></pre>\n<h3>Nested synergy providers</h3>\n<pre><code class=\"language-typescript\" data-meta=\"jsx\">// ---------------------\n// Atoms\n// ---------------------\nconst filterAtom = createAtom(false);\nconst itemsAtom = createAtom([\n  { todo: \"First Todo\", checked: true },\n  { todo: \"Second Todo\", checked: false },\n  { todo: \"Third Todo\", checked: false },\n]);\nconst inputValueAtom = createAtom(\"\");\n\n// ---------------------\n// Selectors and state actions\n// ---------------------\nconst useFilteredItems = createSynergy(itemsAtom, filterAtom).createSelector(\n  (items, filter) => items.filter(({ checked }) => !filter || checked)\n);\n\nconst useAddTodo = createSynergy(itemsAtom, inputValueAtom).createAction(\n  () => (items, input) => {\n    items.current.push({ todo: input.current, checked: false });\n    input.current = \"\";\n  }\n);\n\nconst useToggleTodo = itemsAtom.createAction((id: number) => items => {\n  items.current[id].checked = !items.current[id].checked;\n});\n\nconst useToggleFilter = filterAtom.createAction(() => filter => {\n  filter.current = !filter.current;\n});\n\n// ---------------------\n// Components that use the hooks\n// ---------------------\nconst List = () => {\n  const items = useFilteredItems();\n  const toggle = useToggleTodo();\n\n  return (\n    &#x3C;>\n      {items.map((item, index) => (\n        &#x3C;Checkbox\n          key={index}\n          checked={item.checked}\n          label={item.todo}\n          onChange={() => toggle(index)}\n        />\n      ))}\n    &#x3C;/>\n  );\n};\n\nconst TodoInput = () => {\n  const [value] = inputValueAtom.useValue();\n  const setValue = inputValueAtom.useSet();\n  const addTodo = useAddTodo();\n\n  return (\n    &#x3C;ControlGroup>\n      &#x3C;InputGroup\n        placeholder=\"Add a todo\"\n        value={value}\n        onChange={e => setValue(e.target.value)}\n      />\n      &#x3C;Button onClick={addTodo}>Add&#x3C;/Button>\n    &#x3C;/ControlGroup>\n  );\n};\n\nconst FilterButton = () => {\n  const toggle = useToggleFilter();\n  const [isToggled] = filterAtom.useValue();\n  return (\n    &#x3C;Button onClick={toggle} active={isToggled}>\n      Only show completed todos\n    &#x3C;/Button>\n  );\n};\n\n// ---------------------\n// App container\n// ---------------------\nexport const App = () => (\n  // We don't have to nest the providers so extremely, but this demonstrates how you can inject\n  // atoms at any place in the hierarchy and they can still communicate upwards with other\n  // atoms.\n  &#x3C;SynergyProvider atoms={[filterAtom]}>\n    &#x3C;FilterButton />\n    &#x3C;SynergyProvider atoms={[itemsAtom]}>\n      &#x3C;List />\n      &#x3C;SynergyProvider atoms={[inputValueAtom]}>\n        &#x3C;TodoInput />\n      &#x3C;/SynergyProvider>\n    &#x3C;/SynergyProvider>\n  &#x3C;/SynergyProvider>\n);\n</code></pre>\n<h2>Maintenance</h2>\n<p>When developing locally, run in the root directory...</p>\n<ul>\n<li><code>yarn</code> to install dependencies</li>\n<li><code>yarn test</code> to run tests in all packages</li>\n<li><code>yarn build</code> to build distributables and typings in <code>packages/{package}/out</code></li>\n<li><code>yarn storybook</code> to run a local storybook server</li>\n<li><code>yarn build-storybook</code> to build the storybook</li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/version#readme\"><code>npx lerna version</code></a> to interactively bump the\npackages versions. This automatically commits the version, tags the commit and pushes to git remote.</li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/publish#readme\"><code>npx lerna publish</code></a> to publish all packages\nto NPM that have changed since the last release. This automatically bumps the versions interactively.</li>\n</ul>","excerpt":"Find out more at synergies.js.org! synergies is a tiny (~3kB), yet powerful state management library for React. It allows you to\nspecify small state atoms, that you can combine into Synergies of multiple atoms that define shared state logic.\nFeatures include Distributed state: You can inject indiviâ€¦","frontmatter":{"date":"March 24, 2022","slug":"/projects/synergies","title":"Synergies","category":null,"kind":"project","repo":"lukasbach/synergies","download":null,"template":"advanced","medium":null,"devto":null}}},"pageContext":{"id":"984b14db-af9c-539c-9e0b-b0ea31955353","frontmatter__slug":"/projects/synergies","__params":{"frontmatter__slug":"projects"}}},"staticQueryHashes":["1266385000","3319912920","79628814"],"slicesMap":{}}