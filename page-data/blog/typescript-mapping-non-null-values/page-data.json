{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/typescript-mapping-non-null-values/","result":{"data":{"markdownRemark":{"html":"<p>If you have used JavaScript and array operations for a while, there is a good chance you wanted to filter an array for non-null values. And if you are using TypeScript, there is a chance you ended up with something along the lines of that:</p>\n<pre><code class=\"language-ts\">const array = [\"Michael\", \"Dwight\", undefined, \"Pam\", \"Jim\", undefined]\ntypeof array // (string | undefined)[]\n\nconsole.log(array.map(value => value.includes(\"Mich\")))\n// error, value could be undefined\n// I should filter for only defined values...\n\nconst filteredAttempt = array.filter(value => !!value)\ntypeof filteredAttempt // (string | undefined)[]\n// Argh dang, TypeScript doesn't infer the filter logic, that didn't do anything...\n\n// screw it\nconst filteredAttempt2 = array.filter(value => !!value) as any\ntypeof filteredAttempt2 // any, good enough..\nconsole.log(filteredAttempt2.map(value => value.includes(\"Mich\")))\n</code></pre>\n<p>You will quickly find that TypeScript doesn't actually check what the filter function does, so the returned array will be the same, and you will have to straighten the type manually to make it work, often relying on <code>any</code> which is always a bad idea.</p>\n<p>However, this is really easy to do properly with type guards. A type guard function in TypeScript that takes a parameter <code>x</code> and returns a type of the form <code>x is T</code> with <code>T</code> being any type. Now, if code is called in a scope in which this type guard function was called and returned <code>true</code>, the type of <code>x</code> will be automatically narrowed down to <code>T</code> within that scope:</p>\n<pre><code class=\"language-ts\">const isString = (v: any): v is string =>\n    typeof v === \"string\"\n\nconst stringOrNumber = Math.random() > .5 ? \"hello\" : 42\n\nif (isString(stringOrNumber)) {\n    console.log(stringOrNumber.endsWith(\"lo\")) // works\n} else {\n    console.log(stringOrNumber.toPrecision()) // works\n}\n</code></pre>\n<p>Note that this technically is a type conversion, and you very much can do non sensical stuff with this:</p>\n<pre><code class=\"language-ts\">const surelyAString = (v: any): v is string => true\n\nconst stringOrNumber = Math.random() > .9999 ? \"hello\" : 42\n\nif (surelyAString(stringOrNumber)) {\n    console.log(stringOrNumber.endsWith(\"lo\")) \n    // works, but probably not during runtime\n}\n</code></pre>\n<p>However, it allows you to encapsulate casting logic, which makes the code easier to read and understand which conversions are being made and how they work, thus reducing the likelihood of errors in that logic.</p>\n<p>Returning to the original question: How can we leverage type guards to properly filter an array for non-undefined values?</p>\n<pre><code class=\"language-ts\">const array = [\"Michael\", \"Dwight\", undefined, \"Pam\", \"Jim\", undefined]\ntypeof array // (string | undefined)[]\n\nconst isNotUndefined = &#x3C;T>(value: T | undefined): value is T => \n    value !== undefined\n\nconst filteredArray = array.filter(isNotUndefined)\ntypeof filteredArray // string[]\n\nconsole.log(filteredArray.map(value => value.includes(\"Mich\"))) // works!\n</code></pre>\n<p>We define a type guard function <code>isNotUndefined</code> with generic type <code>T</code>, which takes a parameter of type <code>T | undefined</code>. If we now supply a value of type <code>string | undefined</code>, <code>T</code> is inferred to be <code>string</code>, and the type guard will narrow the type of the parameter down to <code>string</code> if it returns true. This can also be done for filtering out other types such as <code>null</code>.</p>\n<pre><code class=\"language-ts\">const isNotNullish = &#x3C;T>(value: T | null | undefined): value is T => \n    value !== undefined &#x26;&#x26; value !== null\n</code></pre>","excerpt":"If you have used JavaScript and array operations for a while, there is a good chance you wanted to filter an array for non-null values. And if you are using TypeScript, there is a chance you ended up with something along the lines of that: You will quickly find that TypeScript doesn't actually checâ€¦","frontmatter":{"date":"January 13, 2023","slug":"/blog/typescript-mapping-non-null-values","title":"TypeScript: Properly filtering arrays for non-null values","category":"Typescript","kind":"blog","repo":null,"download":null,"template":"page","medium":"https://medium.com/@lukasbach/typescript-properly-filtering-arrays-for-non-null-values-c8c1b5563c6a","devto":"https://dev.to/lukasbach/typescript-properly-filtering-arrays-for-non-null-values-3h5n"}}},"pageContext":{"id":"68095f1b-3f3a-54f3-be73-38d527c2a445","frontmatter__slug":"/blog/typescript-mapping-non-null-values","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["1266385000","3319912920","79628814"],"slicesMap":{}}